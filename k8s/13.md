

## 2. 

```bash
❯ kubectl get po,sts,svc,pvc
NAME                   READY   STATUS    RESTARTS   AGE
pod/app-app-python-0   1/1     Running   0          96s
pod/app-app-python-1   1/1     Running   0          96s

NAME                              READY   AGE
statefulset.apps/app-app-python   2/2     96s

NAME                     TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
service/app-app-python   LoadBalancer   10.107.79.19   <pending>     80:31441/TCP   96s
service/kubernetes       ClusterIP      10.96.0.1      <none>        443/TCP        97m

NAME                                          STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-app-app-python-0   Bound    pvc-3fb4cd92-064b-444b-a3a3-4791f9fa97c6   5Mi        RWO            standard       96m
persistentvolumeclaim/data-app-app-python-1   Bound    pvc-b31b51b4-36ac-4101-a957-b4c36074d7c0   5Mi        RWO            standard       96m
```



```bash
❯ kubectl exec pod/app-app-python-0 -- cat visits
22%
❯ kubectl exec pod/app-app-python-1 -- cat visits
35%
```
### Differences is because I accessed via balancer only one replica. And another visits came from health check


## Explain why ordering guarantees are unnecessary for your app:

Ordering guarantees unnecessary for my application as it's
- Stateless microservices: Independent services that don't rely on strict sequencing.
- Load-balanced systems: Applications distributing requests across instances without strict order dependencies.


## Bonus 
- OnDelete Strategy:

This strategy doesn't trigger automatic updates. Instead, updates occur only upon manual deletion of pods. It offers more control over the update process but requires manual intervention for each update.

- RollingUpdate Strategy:

Contrastingly, the RollingUpdate strategy updates pods sequentially, ensuring that the new pods are fully operational before terminating the old ones. This method allows for a gradual update process, minimizing downtime and potential disruptions.

### Applicability and Use Cases:
I've gained insights into scenarios where each strategy might be more suitable. For instance, the OnDelete strategy could be advantageous in situations where precise control over updates is critical, allowing updates to be triggered at specific times. On the other hand, RollingUpdate proves beneficial for ensuring a seamless update process without significant downtime, suitable for applications with strict availability requirements.